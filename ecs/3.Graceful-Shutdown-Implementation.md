# Graceful Shutdown 완벽 구현 가이드
## Docker 컨테이너 환경에서 안전한 애플리케이션 종료

## 📌 개요

Graceful Shutdown은 애플리케이션이 종료될 때 진행 중인 작업을 안전하게 완료하고, 새로운 요청을 받지 않도록 하는 매우 중요한 패턴이다. 특히 마이크로서비스 환경에서는 배포 시 순간적인 오류를 방지하는 핵심 기능이다.

---

## 🎯 Part 1: Graceful Shutdown 개념과 필요성

### Docker 컨테이너 종료 메커니즘

#### 1. 신호(Signal) 기반 종료
```bash
# SIGTERM 전송 후 10초 대기, 이후 SIGKILL
docker stop <container>

# 즉시 강제 종료
docker kill <container>
```

#### 2. 프로세스 신호 처리 과정
```
1. docker stop 실행
2. Docker가 컨테이너의 메인 프로세스(PID 1)에 SIGTERM 전송
3. 프로세스가 신호를 받아 graceful shutdown 실행
4. 10초 후에도 종료되지 않으면 SIGKILL로 강제 종료
```

### Graceful Shutdown이 없을 때의 문제점

#### 1. 요청 처리 중단
```javascript
// 문제 상황
app.get('/long-process', async (req, res) => {
    // 긴 작업 처리 (예: 파일 업로드, 데이터 처리)
    const result = await processLargeFile(req.file);
    res.json({ result });
});

// 컨테이너 종료 시:
// - 처리 중인 파일 업로드 중단
// - 클라이언트에게 500 에러 반환
// - 데이터 일관성 문제 발생
```

#### 2. 데이터베이스 커넥션 문제
```javascript
// 갑작스러운 종료로 인한 문제
const db = require('./database');

// 트랜잭션 처리 중 강제 종료
await db.beginTransaction();
await db.query('UPDATE accounts SET balance = ?', [newBalance]);
// 여기서 컨테이너 종료 → 롤백되지 않음
await db.query('INSERT INTO transactions ...'); // 실행되지 않음
await db.commit(); // 실행되지 않음
```

#### 3. 실제 서비스 영향
```
배포 시나리오:
1. 새로운 컨테이너 시작
2. 기존 컨테이너 종료 (docker stop)
3. 로드 밸런서가 트래픽을 새 컨테이너로 전환

문제:
- 2-3번 사이의 틈새에 들어온 요청 손실
- 사용자에게 "서비스 점검 중" 메시지
- 업무 시간 배포 불가능
```

---

## 🔧 Part 2: Node.js/Express 환경 구현

### 기본 Graceful Shutdown 구현

#### 1. 신호 처리기 설정
```javascript
// server.js
const express = require('express');
const app = express();
const port = process.env.PORT || 3000;

// Express 서버 시작
const server = app.listen(port, () => {
    console.log(`Server running on port ${port}`);
});

// Graceful Shutdown 구현
const gracefulShutdown = (signal) => {
    console.log(`Received ${signal}, starting graceful shutdown...`);
    
    // 1. 새로운 연결 받지 않기
    server.close((err) => {
        if (err) {
            console.error('Error during server close:', err);
            process.exit(1);
        }
        
        console.log('HTTP server closed');
        
        // 2. 데이터베이스 연결 정리
        // 3. 기타 리소스 정리
        // 4. 프로세스 종료
        console.log('Graceful shutdown completed');
        process.exit(0);
    });
};

// 신호 처리기 등록
process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
process.on('SIGINT', () => gracefulShutdown('SIGINT'));

// 처리되지 않은 예외 처리
process.on('uncaughtException', (err) => {
    console.error('Uncaught Exception:', err);
    gracefulShutdown('uncaughtException');
});

process.on('unhandledRejection', (reason, promise) => {
    console.error('Unhandled Rejection at:', promise, 'reason:', reason);
    gracefulShutdown('unhandledRejection');
});
```

#### 2. 헬스체크 엔드포인트 추가
```javascript
// 서버 상태 관리
let isShuttingDown = false;

// 헬스체크 엔드포인트
app.get('/health', (req, res) => {
    if (isShuttingDown) {
        res.status(503).json({ 
            status: 'shutting down',
            message: 'Server is shutting down'
        });
    } else {
        res.status(200).json({ 
            status: 'healthy',
            uptime: process.uptime(),
            timestamp: new Date().toISOString()
        });
    }
});

// Graceful Shutdown 수정
const gracefulShutdown = (signal) => {
    console.log(`Received ${signal}, starting graceful shutdown...`);
    
    // 상태 변경 (헬스체크가 실패하도록)
    isShuttingDown = true;
    
    // 로드 밸런서가 트래픽을 다른 인스턴스로 보내도록 잠시 대기
    setTimeout(() => {
        server.close((err) => {
            if (err) {
                console.error('Error during server close:', err);
                process.exit(1);
            }
            
            console.log('HTTP server closed');
            process.exit(0);
        });
    }, 2000); // 2초 대기
};
```

### npm 프로세스 문제 해결

#### 1. 문제 상황 분석
```dockerfile
# 문제가 있는 Dockerfile
FROM node:16-alpine
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .

# npm이 메인 프로세스가 되어 신호를 가로챔
CMD ["npm", "start"]
```

```bash
# 프로세스 트리 확인
docker exec <container> ps aux
# PID 1: npm
# PID 15: node server.js

# SIGTERM이 npm에게만 전달되고, node 프로세스는 받지 못함
```

#### 2. 해결 방법들

##### 방법 1: 직접 node 실행
```dockerfile
# 권장 방법
FROM node:16-alpine
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY . .

# npm 대신 직접 node 실행
CMD ["node", "server.js"]
```

##### 방법 2: npm 신호 전달 설정
```json
// package.json
{
  "scripts": {
    "start": "node server.js"
  }
}
```

```dockerfile
# exec를 사용하여 신호 전달
CMD ["sh", "-c", "exec npm start"]
```

##### 방법 3: init 시스템 사용
```dockerfile
# tini 사용 (신호 처리 전문 init 시스템)
FROM node:16-alpine
RUN apk add --no-cache tini
ENTRYPOINT ["/sbin/tini", "--"]
CMD ["node", "server.js"]
```

### 데이터베이스 연결 정리

#### 1. MongoDB 연결 정리
```javascript
const mongoose = require('mongoose');

// 연결 설정
mongoose.connect('mongodb://localhost:27017/myapp', {
    useNewUrlParser: true,
    useUnifiedTopology: true,
});

const gracefulShutdown = async (signal) => {
    console.log(`Received ${signal}, starting graceful shutdown...`);
    
    server.close(async (err) => {
        if (err) {
            console.error('Error during server close:', err);
            process.exit(1);
        }
        
        try {
            // MongoDB 연결 닫기
            await mongoose.connection.close();
            console.log('MongoDB connection closed');
            
            console.log('Graceful shutdown completed');
            process.exit(0);
        } catch (error) {
            console.error('Error during MongoDB close:', error);
            process.exit(1);
        }
    });
};
```

#### 2. PostgreSQL 연결 정리
```javascript
const { Pool } = require('pg');

const pool = new Pool({
    connectionString: process.env.DATABASE_URL,
    max: 20,
    idleTimeoutMillis: 30000,
    connectionTimeoutMillis: 2000,
});

const gracefulShutdown = (signal) => {
    console.log(`Received ${signal}, starting graceful shutdown...`);
    
    server.close(async (err) => {
        if (err) {
            console.error('Error during server close:', err);
            process.exit(1);
        }
        
        try {
            // PostgreSQL 커넥션 풀 닫기
            await pool.end();
            console.log('PostgreSQL connection pool closed');
            
            console.log('Graceful shutdown completed');
            process.exit(0);
        } catch (error) {
            console.error('Error during pool close:', error);
            process.exit(1);
        }
    });
};
```

#### 3. Redis 연결 정리
```javascript
const redis = require('redis');
const client = redis.createClient({
    host: process.env.REDIS_HOST || 'localhost',
    port: process.env.REDIS_PORT || 6379,
});

const gracefulShutdown = (signal) => {
    console.log(`Received ${signal}, starting graceful shutdown...`);
    
    server.close((err) => {
        if (err) {
            console.error('Error during server close:', err);
            process.exit(1);
        }
        
        // Redis 연결 닫기
        client.quit((err) => {
            if (err) {
                console.error('Error during Redis close:', err);
            } else {
                console.log('Redis connection closed');
            }
            
            console.log('Graceful shutdown completed');
            process.exit(err ? 1 : 0);
        });
    });
};
```

---

## 🌐 Part 3: 다양한 환경별 구현

### Express.js with TypeScript
```typescript
// server.ts
import express from 'express';
import { createConnection, Connection } from 'typeorm';
import { Server } from 'http';

interface ShutdownManager {
    server: Server;
    database: Connection;
    isShuttingDown: boolean;
}

class GracefulShutdown {
    private shutdownManager: ShutdownManager;
    private shutdownTimeout: number;

    constructor(server: Server, database: Connection, timeout: number = 30000) {
        this.shutdownManager = {
            server,
            database,
            isShuttingDown: false
        };
        this.shutdownTimeout = timeout;
        
        this.setupSignalHandlers();
    }

    private setupSignalHandlers(): void {
        const signals: NodeJS.Signals[] = ['SIGTERM', 'SIGINT'];
        
        signals.forEach(signal => {
            process.on(signal, () => this.shutdown(signal));
        });
    }

    private async shutdown(signal: string): Promise<void> {
        if (this.shutdownManager.isShuttingDown) {
            console.log('Shutdown already in progress...');
            return;
        }

        console.log(`Received ${signal}, starting graceful shutdown...`);
        this.shutdownManager.isShuttingDown = true;

        // 타임아웃 설정
        const shutdownTimer = setTimeout(() => {
            console.error('Graceful shutdown timeout, forcing exit');
            process.exit(1);
        }, this.shutdownTimeout);

        try {
            // HTTP 서버 종료
            await this.closeServer();
            
            // 데이터베이스 연결 종료
            await this.closeDatabase();
            
            console.log('Graceful shutdown completed');
            clearTimeout(shutdownTimer);
            process.exit(0);
        } catch (error) {
            console.error('Error during graceful shutdown:', error);
            clearTimeout(shutdownTimer);
            process.exit(1);
        }
    }

    private closeServer(): Promise<void> {
        return new Promise((resolve, reject) => {
            this.shutdownManager.server.close((err) => {
                if (err) {
                    reject(err);
                } else {
                    console.log('HTTP server closed');
                    resolve();
                }
            });
        });
    }

    private async closeDatabase(): Promise<void> {
        if (this.shutdownManager.database.isConnected) {
            await this.shutdownManager.database.close();
            console.log('Database connection closed');
        }
    }

    public isShuttingDown(): boolean {
        return this.shutdownManager.isShuttingDown;
    }
}

// 사용 예제
const app = express();
const port = process.env.PORT || 3000;

// 헬스체크 (Graceful Shutdown 인스턴스가 필요)
let gracefulShutdown: GracefulShutdown;

app.get('/health', (req, res) => {
    if (gracefulShutdown && gracefulShutdown.isShuttingDown()) {
        res.status(503).json({ status: 'shutting down' });
    } else {
        res.status(200).json({ status: 'healthy' });
    }
});

// 서버 시작
const server = app.listen(port, async () => {
    console.log(`Server running on port ${port}`);
    
    // 데이터베이스 연결
    const database = await createConnection();
    
    // Graceful Shutdown 설정
    gracefulShutdown = new GracefulShutdown(server, database);
});
```

### Fastify 프레임워크
```javascript
// fastify-server.js
const fastify = require('fastify')({ logger: true });

// 플러그인 등록
fastify.register(require('fastify-postgres'), {
    connectionString: process.env.DATABASE_URL
});

// 헬스체크 라우트
fastify.get('/health', async (request, reply) => {
    if (fastify.isShuttingDown) {
        reply.code(503).send({ status: 'shutting down' });
    } else {
        reply.send({ status: 'healthy' });
    }
});

// Graceful Shutdown
const gracefulShutdown = async (signal) => {
    fastify.log.info(`Received ${signal}, starting graceful shutdown...`);
    
    try {
        // Fastify는 close() 메서드가 모든 플러그인을 정리함
        await fastify.close();
        fastify.log.info('Graceful shutdown completed');
        process.exit(0);
    } catch (err) {
        fastify.log.error('Error during graceful shutdown:', err);
        process.exit(1);
    }
};

// 신호 처리기
process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
process.on('SIGINT', () => gracefulShutdown('SIGINT'));

// 서버 시작
const start = async () => {
    try {
        await fastify.listen(3000, '0.0.0.0');
        fastify.log.info('Server is running on port 3000');
    } catch (err) {
        fastify.log.error(err);
        process.exit(1);
    }
};

start();
```

### Koa.js 프레임워크
```javascript
// koa-server.js
const Koa = require('koa');
const Router = require('koa-router');

const app = new Koa();
const router = new Router();

let isShuttingDown = false;

// 미들웨어: Shutdown 중에는 503 반환
app.use(async (ctx, next) => {
    if (isShuttingDown && ctx.path !== '/health') {
        ctx.status = 503;
        ctx.body = { error: 'Server is shutting down' };
        return;
    }
    await next();
});

// 헬스체크
router.get('/health', (ctx) => {
    if (isShuttingDown) {
        ctx.status = 503;
        ctx.body = { status: 'shutting down' };
    } else {
        ctx.status = 200;
        ctx.body = { status: 'healthy' };
    }
});

app.use(router.routes());

// 서버 시작
const server = app.listen(3000, () => {
    console.log('Koa server running on port 3000');
});

// Graceful Shutdown
const gracefulShutdown = (signal) => {
    console.log(`Received ${signal}, starting graceful shutdown...`);
    isShuttingDown = true;
    
    setTimeout(() => {
        server.close((err) => {
            if (err) {
                console.error('Error during server close:', err);
                process.exit(1);
            }
            
            console.log('Koa server closed');
            process.exit(0);
        });
    }, 2000);
};

process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
process.on('SIGINT', () => gracefulShutdown('SIGINT'));
```

---

## 🐳 Part 4: Docker 최적화

### Dockerfile 최적화

#### 1. 멀티스테이지 빌드 + Graceful Shutdown
```dockerfile
# Build stage
FROM node:16-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

# Production stage
FROM node:16-alpine
WORKDIR /app

# 보안 강화: non-root 사용자 생성
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nodejs -u 1001

# 애플리케이션 파일 복사
COPY --from=builder /app/node_modules ./node_modules
COPY --chown=nodejs:nodejs . .

# 사용자 변경
USER nodejs

# 포트 노출
EXPOSE 3000

# Graceful Shutdown을 위한 올바른 시작 명령
CMD ["node", "server.js"]
```

#### 2. 신호 처리 최적화
```dockerfile
# tini 사용 (더 나은 신호 처리)
FROM node:16-alpine
RUN apk add --no-cache tini

WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY . .

# tini를 init 프로세스로 사용
ENTRYPOINT ["/sbin/tini", "--"]
CMD ["node", "server.js"]
```

#### 3. .dockerignore 최적화
```dockerignore
node_modules
npm-debug.log
.nyc_output
coverage
.coverage
.env
.git
.gitignore
README.md
.eslintrc
.prettierrc
Dockerfile
.dockerignore
docker-compose.yml
```

### Docker Compose 설정
```yaml
# docker-compose.yml
version: '3.8'

services:
  app:
    build: .
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - DATABASE_URL=postgres://user:pass@db:5432/mydb
    depends_on:
      - db
    restart: unless-stopped
    # Graceful Shutdown 설정
    stop_grace_period: 30s
    stop_signal: SIGTERM
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  db:
    image: postgres:13-alpine
    environment:
      - POSTGRES_DB=mydb
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=pass
    volumes:
      - db_data:/var/lib/postgresql/data
    restart: unless-stopped

volumes:
  db_data:
```

---

## 🚀 Part 5: 프로덕션 배포 전략

### 로드 밸런서 헬스체크 연동

#### 1. ALB Target Group 설정
```json
{
  "HealthCheckPath": "/health",
  "HealthCheckProtocol": "HTTP",
  "HealthCheckPort": "traffic-port",
  "HealthyThresholdCount": 2,
  "UnhealthyThresholdCount": 3,
  "HealthCheckTimeoutSeconds": 5,
  "HealthCheckIntervalSeconds": 30,
  "Matcher": {
    "HttpCode": "200"
  }
}
```

#### 2. 배포 과정에서의 Graceful Shutdown
```
1. 새로운 컨테이너 시작
   └── 헬스체크 통과까지 대기

2. 로드 밸런서에 새 타겟 등록
   └── 새 타겟이 healthy 상태 확인

3. 기존 컨테이너에 SIGTERM 전송
   └── 헬스체크 실패 응답 시작
   └── 로드 밸런서가 트래픽 중단
   └── 기존 요청 처리 완료
   └── 컨테이너 정상 종료

4. 기존 타겟 등록 해제
```

### ECS 배포 설정
```json
{
  "family": "my-app",
  "networkMode": "awsvpc",
  "requiresCompatibilities": ["FARGATE"],
  "cpu": "256",
  "memory": "512",
  "containerDefinitions": [
    {
      "name": "app",
      "image": "my-app:latest",
      "portMappings": [
        {
          "containerPort": 3000
        }
      ],
      "healthCheck": {
        "command": [
          "CMD-SHELL",
          "curl -f http://localhost:3000/health || exit 1"
        ],
        "interval": 30,
        "timeout": 5,
        "retries": 3,
        "startPeriod": 60
      },
      "stopTimeout": 30,
      "logConfiguration": {
        "logDriver": "awslogs",
        "options": {
          "awslogs-group": "/ecs/my-app",
          "awslogs-region": "ap-northeast-2",
          "awslogs-stream-prefix": "ecs"
        }
      }
    }
  ]
}
```

### Kubernetes 배포
```yaml
# deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app
spec:
  replicas: 3
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 0
      maxSurge: 1
  selector:
    matchLabels:
      app: my-app
  template:
    metadata:
      labels:
        app: my-app
    spec:
      containers:
      - name: app
        image: my-app:latest
        ports:
        - containerPort: 3000
        # Graceful Shutdown 설정
        lifecycle:
          preStop:
            exec:
              command:
              - /bin/sh
              - -c
              - sleep 5  # 로드밸런서가 엔드포인트 제거할 시간
        # 헬스체크
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 5
        # 리소스 제한
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        # 종료 grace period
        terminationGracePeriodSeconds: 30
```

---

## 📊 Part 6: 모니터링과 테스트

### 로깅 전략
```javascript
// structured-logging.js
const winston = require('winston');

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  transports: [
    new winston.transports.Console(),
    new winston.transports.File({ filename: 'app.log' })
  ]
});

// Graceful Shutdown에서 사용
const gracefulShutdown = (signal) => {
  logger.info('Graceful shutdown initiated', { 
    signal,
    timestamp: new Date().toISOString(),
    pid: process.pid
  });
  
  server.close((err) => {
    if (err) {
      logger.error('Error during server close', { 
        error: err.message,
        stack: err.stack 
      });
      process.exit(1);
    }
    
    logger.info('Server closed successfully');
    process.exit(0);
  });
};
```

### 메트릭 수집
```javascript
// metrics.js
const promClient = require('prom-client');

// 메트릭 정의
const httpRequestDuration = new promClient.Histogram({
  name: 'http_request_duration_ms',
  help: 'Duration of HTTP requests in ms',
  labelNames: ['method', 'route', 'status_code'],
  buckets: [1, 5, 15, 50, 100, 500]
});

const activeConnections = new promClient.Gauge({
  name: 'active_connections',
  help: 'Number of active connections'
});

// Graceful Shutdown 메트릭
const shutdownDuration = new promClient.Histogram({
  name: 'shutdown_duration_seconds',
  help: 'Time taken for graceful shutdown',
  buckets: [1, 5, 10, 30, 60]
});

// Express 미들웨어
app.use((req, res, next) => {
  const start = Date.now();
  
  res.on('finish', () => {
    const duration = Date.now() - start;
    httpRequestDuration
      .labels(req.method, req.route?.path || req.path, res.statusCode)
      .observe(duration);
  });
  
  next();
});

// 서버 연결 추적
server.on('connection', (socket) => {
  activeConnections.inc();
  socket.on('close', () => {
    activeConnections.dec();
  });
});

// Graceful Shutdown에서 메트릭 기록
const gracefulShutdown = (signal) => {
  const shutdownTimer = shutdownDuration.startTimer();
  
  logger.info('Starting graceful shutdown', { signal });
  
  server.close((err) => {
    shutdownTimer();
    
    if (err) {
      logger.error('Shutdown error', { error: err.message });
      process.exit(1);
    }
    
    logger.info('Graceful shutdown completed');
    process.exit(0);
  });
};
```

### 테스트 시나리오
```javascript
// test/graceful-shutdown.test.js
const request = require('supertest');
const { spawn } = require('child_process');

describe('Graceful Shutdown', () => {
  let serverProcess;
  let baseURL;
  
  beforeEach(() => {
    return new Promise((resolve) => {
      serverProcess = spawn('node', ['server.js'], {
        env: { ...process.env, PORT: '0' }
      });
      
      serverProcess.stdout.on('data', (data) => {
        const output = data.toString();
        const match = output.match(/Server running on port (\d+)/);
        if (match) {
          baseURL = `http://localhost:${match[1]}`;
          resolve();
        }
      });
    });
  });
  
  afterEach(() => {
    if (serverProcess) {
      serverProcess.kill('SIGKILL');
    }
  });
  
  test('should handle SIGTERM gracefully', async () => {
    // 서버가 정상 동작하는지 확인
    const response = await request(baseURL).get('/health');
    expect(response.status).toBe(200);
    
    // SIGTERM 전송
    serverProcess.kill('SIGTERM');
    
    // 잠시 후 서버가 종료되었는지 확인
    await new Promise(resolve => setTimeout(resolve, 3000));
    
    try {
      await request(baseURL).get('/health');
      fail('Server should be closed');
    } catch (err) {
      expect(err.code).toBe('ECONNREFUSED');
    }
  });
  
  test('should complete ongoing requests during shutdown', async () => {
    // 긴 요청 시작
    const longRequestPromise = request(baseURL)
      .get('/slow-endpoint')
      .timeout(10000);
    
    // 잠시 후 SIGTERM 전송
    setTimeout(() => {
      serverProcess.kill('SIGTERM');
    }, 100);
    
    // 긴 요청이 완료되어야 함
    const response = await longRequestPromise;
    expect(response.status).toBe(200);
  });
});
```

---

## 🎯 Part 7: 고급 패턴과 최적화

### Circuit Breaker와 함께 사용
```javascript
// circuit-breaker-shutdown.js
const CircuitBreaker = require('opossum');

// 외부 서비스 호출용 Circuit Breaker
const options = {
  timeout: 3000,
  errorThresholdPercentage: 50,
  resetTimeout: 30000
};

const breaker = new CircuitBreaker(callExternalService, options);

// Graceful Shutdown 시 Circuit Breaker도 정리
const gracefulShutdown = async (signal) => {
  console.log(`Received ${signal}, starting graceful shutdown...`);
  
  // 1. 새로운 요청 차단
  isShuttingDown = true;
  
  // 2. Circuit Breaker 비활성화
  breaker.disable();
  
  // 3. 진행 중인 요청 완료 대기
  server.close(async (err) => {
    if (err) {
      console.error('Error during server close:', err);
      process.exit(1);
    }
    
    // 4. Circuit Breaker 통계 저장 (선택사항)
    console.log('Circuit Breaker Stats:', breaker.stats);
    
    process.exit(0);
  });
};
```

### Worker Pool과 함께 사용
```javascript
// worker-pool-shutdown.js
const { Worker, isMainThread, parentPort, workerData } = require('worker_threads');

if (isMainThread) {
  // 메인 스레드
  const workers = [];
  const maxWorkers = 4;
  
  // 워커 생성
  for (let i = 0; i < maxWorkers; i++) {
    const worker = new Worker(__filename, {
      workerData: { workerId: i }
    });
    workers.push(worker);
  }
  
  // Graceful Shutdown
  const gracefulShutdown = async (signal) => {
    console.log(`Received ${signal}, shutting down workers...`);
    
    // 모든 워커에게 종료 신호 전송
    const shutdownPromises = workers.map(worker => {
      return new Promise((resolve) => {
        worker.postMessage({ type: 'shutdown' });
        worker.on('exit', resolve);
      });
    });
    
    // 모든 워커 종료 대기
    await Promise.all(shutdownPromises);
    console.log('All workers shut down');
    
    // 메인 서버 종료
    server.close(() => {
      process.exit(0);
    });
  };
  
  process.on('SIGTERM', gracefulShutdown);
  process.on('SIGINT', gracefulShutdown);
  
} else {
  // 워커 스레드
  let isWorkerShuttingDown = false;
  
  parentPort.on('message', (msg) => {
    if (msg.type === 'shutdown') {
      isWorkerShuttingDown = true;
      
      // 진행 중인 작업 완료 후 종료
      finishCurrentWork().then(() => {
        process.exit(0);
      });
    }
  });
  
  async function finishCurrentWork() {
    // 현재 작업 완료
    console.log(`Worker ${workerData.workerId} finishing current work...`);
    // 실제 정리 작업
  }
}
```

### Redis Pub/Sub과 함께 사용
```javascript
// redis-pubsub-shutdown.js
const redis = require('redis');

const publisher = redis.createClient();
const subscriber = redis.createClient();

subscriber.subscribe('notifications');

subscriber.on('message', (channel, message) => {
  console.log(`Received message: ${message}`);
});

const gracefulShutdown = async (signal) => {
  console.log(`Received ${signal}, starting graceful shutdown...`);
  
  // 1. Subscriber 정리
  subscriber.unsubscribe();
  await new Promise(resolve => {
    subscriber.quit(resolve);
  });
  
  // 2. Publisher 정리
  await new Promise(resolve => {
    publisher.quit(resolve);
  });
  
  // 3. HTTP 서버 정리
  server.close(() => {
    console.log('Graceful shutdown completed');
    process.exit(0);
  });
};

process.on('SIGTERM', gracefulShutdown);
process.on('SIGINT', gracefulShutdown);
```

---

## 🎬 결론과 베스트 프랙티스

### 핵심 원칙

#### 1. 신호 처리의 원칙
```javascript
// ✅ 좋은 예
process.on('SIGTERM', gracefulShutdown);
process.on('SIGINT', gracefulShutdown);

// ❌ 나쁜 예 (무시)
process.on('SIGTERM', () => {});
```

#### 2. 타임아웃 설정
```javascript
// ✅ 적절한 타임아웃 설정
const SHUTDOWN_TIMEOUT = 30000; // 30초

setTimeout(() => {
  console.error('Graceful shutdown timeout, forcing exit');
  process.exit(1);
}, SHUTDOWN_TIMEOUT);
```

#### 3. 리소스 정리 순서
```javascript
const gracefulShutdown = async (signal) => {
  // 1. 새로운 요청 차단
  isShuttingDown = true;
  
  // 2. 헬스체크 실패 응답
  // 3. HTTP 서버 종료 (새 연결 차단)
  // 4. 진행 중인 요청 완료 대기
  // 5. 데이터베이스 연결 정리
  // 6. 기타 리소스 정리
  // 7. 프로세스 종료
};
```

### 체크리스트

#### Docker 환경
- [ ] npm 대신 직접 node 실행
- [ ] 적절한 STOP_TIMEOUT 설정
- [ ] 헬스체크 엔드포인트 구현
- [ ] 로그 구조화

#### 애플리케이션
- [ ] SIGTERM/SIGINT 핸들러 구현
- [ ] 서버 클로즈 로직 구현
- [ ] 데이터베이스 연결 정리
- [ ] 타임아웃 처리

#### 인프라
- [ ] 로드 밸런서 헬스체크 연동
- [ ] 배포 전략 (롤링 업데이트)
- [ ] 모니터링 및 알림
- [ ] 테스트 자동화

### 성능 최적화 팁

#### 1. 빠른 종료를 위한 최적화
```javascript
// Keep-Alive 연결 관리
const server = app.listen(port);

// 기본 Keep-Alive 타임아웃 단축
server.keepAliveTimeout = 5000;  // 5초
server.headersTimeout = 6000;    // 6초

// 연결 추적
const connections = new Set();

server.on('connection', (conn) => {
  connections.add(conn);
  conn.on('close', () => {
    connections.delete(conn);
  });
});

const gracefulShutdown = (signal) => {
  // 활성 연결 강제 종료 (필요시)
  for (const conn of connections) {
    conn.destroy();
  }
  
  server.close(() => {
    process.exit(0);
  });
};
```

#### 2. 메모리 누수 방지
```javascript
// 이벤트 리스너 정리
const gracefulShutdown = (signal) => {
  // 모든 이벤트 리스너 제거
  process.removeAllListeners('SIGTERM');
  process.removeAllListeners('SIGINT');
  process.removeAllListeners('uncaughtException');
  process.removeAllListeners('unhandledRejection');
  
  // 서버 종료
  server.close(() => {
    process.exit(0);
  });
};
```

### 마지막 권장사항

1. **작게 시작하기**: 기본적인 SIGTERM 처리부터 시작
2. **점진적 개선**: 헬스체크 → 데이터베이스 정리 → 고급 기능 순으로 추가
3. **테스트 중요성**: 실제 프로덕션과 유사한 환경에서 테스트
4. **모니터링 필수**: 종료 시간과 실패율 지속적 모니터링
5. **문서화**: 팀 전체가 이해할 수 있도록 명확한 문서 작성

Graceful Shutdown은 안정적인 서비스 운영의 기본이다. 한 번 제대로 구현해두면 배포 시 신경 쓸 일이 현저히 줄어들고, 사용자 경험도 크게 개선된다.