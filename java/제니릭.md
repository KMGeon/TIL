# 자바 제네릭 완벽 가이드

## 📋 핵심 요약

```
요약: 자바 제네릭
제네릭은 타입 안전성과 코드 재사용성을 동시에 제공하는 자바의 핵심 기능이다.
* 🎯 컴파일 시점에 타입 체크로 런타임 오류 방지
* 💡 하나의 코드로 여러 타입 지원 (코드 재사용성)
* ⚡ 타입 캐스팅 불필요, 코드 간결성 향상
* 🔍 타입 이레이저로 런타임시 제네릭 정보 소거
```

## 🎯 목차

1. [제네릭이 필요한 이유](#1-제네릭이-필요한-이유)
2. [제네릭 기본 개념](#2-제네릭-기본-개념)
3. [제네릭 용어와 문법](#3-제네릭-용어와-문법)
4. [타입 매개변수 제한](#4-타입-매개변수-제한)
5. [제네릭 메서드](#5-제네릭-메서드)
6. [와일드카드](#6-와일드카드)
7. [타입 이레이저](#7-타입-이레이저)
8. [실습 예제](#8-실습-예제)

---

## 1. 제네릭이 필요한 이유

### ❌ 제네릭 없이 Object 사용시 문제점

```java
// Object를 사용한 박스
class ObjectBox {
    private Object value;
    
    public void set(Object value) {
        this.value = value;
    }
    
    public Object get() {
        return value;
    }
}

// 사용 예시
ObjectBox intBox = new ObjectBox();
intBox.set(10);
Integer result = (Integer) intBox.get(); // 🚨 타입 캐스팅 필요

intBox.set("Hello"); // 🚨 런타임에 다른 타입 저장 가능
Integer result2 = (Integer) intBox.get(); // 💥 ClassCastException 발생!
```

**문제점:**
- 런타임에 `ClassCastException` 발생 위험
- 타입 캐스팅이 반드시 필요
- 컴파일 시점에 타입 오류 감지 불가

---

## 2. 제네릭 기본 개념

### ✅ 제네릭을 사용한 해결책

```java
// 제네릭을 사용한 박스
class GenericBox<T> {
    private T value;
    
    public void set(T value) {
        this.value = value;
    }
    
    public T get() {
        return value;
    }
}

// 사용 예시
GenericBox<Integer> intBox = new GenericBox<>();
intBox.set(10);
Integer result = intBox.get(); // ✅ 캐스팅 불필요

// intBox.set("Hello"); // 💡 컴파일 오류로 사전 차단!
```

**장점:**
- 컴파일 시점에 타입 체크
- 타입 캐스팅 불필요
- 코드 재사용성 향상

---

## 3. 제네릭 용어와 문법

### 📚 핵심 용어

| 용어 | 설명 | 예시 |
|------|------|------|
| **제네릭 타입** | 타입 매개변수를 사용하는 클래스/인터페이스 | `class Box<T>` |
| **타입 매개변수** | 실제 타입으로 대체될 변수 | `<T>`, `<E>`, `<K,V>` |
| **타입 인자** | 제네릭 타입 사용시 제공하는 실제 타입 | `Box<Integer>` |
| **로 타입** | 타입 인자 없이 사용하는 제네릭 타입 | `Box box` |

### 🔤 타입 매개변수 명명 관례

```java
// 일반적인 관례
<T>          // Type
<E>          // Element (컬렉션)
<K, V>       // Key, Value (맵)
<N>          // Number
<S, U, V>    // 2번째, 3번째, 4번째 타입
```

### ⚠️ 제한사항

```java
// ❌ 기본형 타입 사용 불가
GenericBox<int> intBox;     // 컴파일 오류

// ✅ 래퍼 클래스 사용
GenericBox<Integer> intBox; // 정상
```

---

## 4. 타입 매개변수 제한

### 🎯 상한 제한 (extends)

```java
// Animal과 그 자식 클래스만 허용
class AnimalHospital<T extends Animal> {
    private T animal;
    
    public void checkup(T animal) {
        animal.getName();  // ✅ Animal 메서드 사용 가능
        animal.sound();    // ✅ Animal 메서드 사용 가능
    }
}

// 사용 예시
AnimalHospital<Dog> dogHospital = new AnimalHospital<>();    // ✅
AnimalHospital<Cat> catHospital = new AnimalHospital<>();    // ✅
// AnimalHospital<Integer> intHospital = new AnimalHospital<>(); // ❌ 컴파일 오류
```

**효과:**
- 특정 타입의 메서드 사용 가능
- 타입 안전성 보장
- 의미있는 제한으로 오류 방지

---

## 5. 제네릭 메서드

### 🔧 기본 문법

```java
public class GenericMethod {
    // 제네릭 메서드 선언
    public static <T> T genericMethod(T t) {
        System.out.println("Generic method: " + t);
        return t;
    }
    
    // 상한 제한이 있는 제네릭 메서드
    public static <T extends Number> void numberMethod(T t) {
        System.out.println("Number: " + t.doubleValue());
    }
}
```

### 🚀 사용 예시

```java
// 명시적 타입 지정
String result1 = GenericMethod.<String>genericMethod("Hello");

// 타입 추론 (권장)
String result2 = GenericMethod.genericMethod("Hello");
Integer result3 = GenericMethod.genericMethod(123);
```

### 📝 static 메서드에서의 제네릭

```java
class MyClass<T> {
    private T value;
    
    // ❌ 클래스의 T를 static 메서드에서 사용 불가
    // public static void staticMethod(T t) { }
    
    // ✅ 제네릭 메서드로 해결
    public static <U> void staticMethod(U u) {
        System.out.println(u);
    }
}
```

---

## 6. 와일드카드

### 🎭 와일드카드 종류

| 종류 | 문법 | 설명 | 사용 시기 |
|------|------|------|-----------|
| **비제한** | `<?>` | 모든 타입 허용 | 타입에 관계없이 작업 |
| **상한 제한** | `<? extends T>` | T와 그 자식 타입만 허용 | 데이터 읽기 (Producer) |
| **하한 제한** | `<? super T>` | T와 그 부모 타입만 허용 | 데이터 쓰기 (Consumer) |

### 📖 상한 와일드카드 (extends)

```java
// Animal과 그 자식들을 담은 박스만 처리
public static void processAnimalBox(Box<? extends Animal> box) {
    Animal animal = box.get(); // ✅ Animal로 읽기 가능
    // box.set(new Dog());     // ❌ 쓰기 불가 (null만 가능)
}

// 사용
Box<Dog> dogBox = new Box<>();
Box<Cat> catBox = new Box<>();
processAnimalBox(dogBox); // ✅
processAnimalBox(catBox); // ✅
```

### 📝 하한 와일드카드 (super)

```java
// Animal과 그 부모들을 담은 박스만 처리
public static void addAnimal(Box<? super Animal> box) {
    box.set(new Dog());    // ✅ Animal의 자식 추가 가능
    box.set(new Cat());    // ✅ Animal의 자식 추가 가능
    Object obj = box.get(); // ✅ Object로만 읽기 가능
}

// 사용
Box<Animal> animalBox = new Box<>();
Box<Object> objectBox = new Box<>();
addAnimal(animalBox); // ✅
addAnimal(objectBox); // ✅
```

### 💡 PECS 원칙

```
Producer Extends, Consumer Super
- 데이터를 생산(읽기)할 때: <? extends T>
- 데이터를 소비(쓰기)할 때: <? super T>
```

---

## 7. 타입 이레이저

### 🔄 컴파일 과정에서 일어나는 일

```java
// 컴파일 전 (소스 코드)
class Box<T> {
    private T value;
    public T get() { return value; }
    public void set(T value) { this.value = value; }
}

// 컴파일 후 (바이트코드) - 타입 이레이저 적용
class Box {
    private Object value;  // T → Object
    public Object get() { return value; }
    public void set(Object value) { this.value = value; }
}
```

### 📊 상한 제한이 있는 경우

```java
// 컴파일 전
class NumberBox<T extends Number> {
    private T value;
}

// 컴파일 후
class NumberBox {
    private Number value;  // T → Number (상한으로 대체)
}
```

### ⚠️ 타입 이레이저의 한계

```java
public class TypeErasureLimitation<T> {
    // ❌ 불가능한 작업들
    // new T();                    // 인스턴스 생성 불가
    // T.class;                    // 클래스 리터럴 불가
    // instanceof T;               // instanceof 불가
    // T[] array = new T[10];      // 배열 생성 불가
}
```

---

## 8. 실습 예제

### 🎯 예제 1: Container 클래스

```java
public class Container<T> {
    private T item;
    
    public void setItem(T item) {
        this.item = item;
    }
    
    public T getItem() {
        return item;
    }
    
    public boolean isEmpty() {
        return item == null;
    }
}

// 사용
Container<String> stringContainer = new Container<>();
stringContainer.setItem("Hello");
String value = stringContainer.getItem();
```

### 🎯 예제 2: Pair 클래스

```java
public class Pair<T1, T2> {
    private T1 first;
    private T2 second;
    
    public Pair(T1 first, T2 second) {
        this.first = first;
        this.second = second;
    }
    
    public T1 getFirst() { return first; }
    public T2 getSecond() { return second; }
    
    @Override
    public String toString() {
        return "Pair{first=" + first + ", second=" + second + "}";
    }
}

// 사용
Pair<String, Integer> pair = new Pair<>("Hello", 100);
```

### 🎯 예제 3: 유틸리티 메서드

```java
public class GenericUtils {
    // 두 값 중 큰 값 반환
    public static <T extends Comparable<T>> T max(T a, T b) {
        return a.compareTo(b) > 0 ? a : b;
    }
    
    // 배열을 리스트로 변환
    public static <T> List<T> arrayToList(T[] array) {
        return Arrays.asList(array);
    }
}

// 사용
Integer maxValue = GenericUtils.max(10, 20);
List<String> list = GenericUtils.arrayToList(new String[]{"a", "b", "c"});
```

---

## 🎯 핵심 정리

### 📌 반드시 기억할 것

1. **타입 안전성**: 컴파일 시점에 타입 체크로 런타임 오류 방지
2. **코드 재사용성**: 하나의 코드로 여러 타입 지원
3. **타입 이레이저**: 런타임에는 제네릭 정보가 사라짐

### 🔗 자주 사용하는 패턴

```java
// 컬렉션
List<String> list = new ArrayList<>();
Map<String, Integer> map = new HashMap<>();

// 와일드카드
List<? extends Number> numbers;  // 읽기 전용
List<? super Integer> integers;  // 쓰기 가능

// 제네릭 메서드
public static <T> void swap(T[] array, int i, int j)
```

### 💡 베스트 프랙티스

- 로 타입 사용 금지
- 적절한 와일드카드 사용 (PECS 원칙)
- 타입 매개변수에 의미있는 이름 사용
- 필요시 상한 제한으로 기능 확장

---

## 📚 참고 자료

- [Oracle 제네릭 공식 문서](https://docs.oracle.com/javase/tutorial/java/generics/)
- [Effective Java - 제네릭 관련 아이템들](https://www.oracle.com/technical-resources/articles/java/juneau-generics.html)