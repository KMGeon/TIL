# 📝 TIL (Today I Learned) - JTA (Java Transaction API) 구성

## JTA 개요
JTA는 Java 환경에서 분산 트랜잭션을 관리하기 위한 API로, 여러 데이터소스에 걸친 트랜잭션을 ACID 속성을 보장하면서 처리할 수 있게 해줍니다.

## 의존성 추가

```gradle
// Atomikos JTA 구현체 (Spring Boot 3용)
implementation group: 'com.atomikos', name: 'transactions-spring-boot3-starter', version: '6.0.0'
// Jakarta Transaction API
implementation group: 'jakarta.transaction', name: 'jakarta.transaction-api', version: '2.0.1'
```

## JTA 설정 구성

### 주요 컴포넌트

1. **UserTransactionManager**: Atomikos의 트랜잭션 매니저
2. **UserTransaction**: 사용자 트랜잭션 인터페이스 
3. **JtaTransactionManager**: Spring의 JTA 트랜잭션 매니저
4. **AtomikosDataSourceBean**: XA 지원 데이터소스

### 설정 코드

```java
@Configuration
@EnableTransactionManagement
public class JtaDataSourceConfig {

    // Atomikos 트랜잭션 매니저 설정
    @Bean(initMethod = "init", destroyMethod = "close")
    public UserTransactionManager userTransactionManager() {
        UserTransactionManager userTransactionManager = new UserTransactionManager();
        userTransactionManager.setForceShutdown(false);
        return userTransactionManager;
    }

    // 사용자 트랜잭션 설정 (타임아웃 60초)
    @Bean
    public UserTransaction userTransaction() throws SystemException {
        UserTransactionImp userTransactionImp = new UserTransactionImp();
        userTransactionImp.setTransactionTimeout(60);
        return userTransactionImp;
    }

    // Spring JTA 트랜잭션 매니저
    @Bean("jtaTransaction")
    public PlatformTransactionManager transactionManager() throws SystemException {
        JtaTransactionManager jtaTransactionManager = new JtaTransactionManager();
        jtaTransactionManager.setUserTransaction(userTransaction());
        jtaTransactionManager.setTransactionManager(userTransactionManager());
        return jtaTransactionManager;
    }

    // 첫 번째 XA 데이터소스
    @Bean("jtaGtgearDataSource")
    public DataSource jtaGtgearDataSource() {
        AtomikosDataSourceBean dataSourceBean = new AtomikosDataSourceBean();
        dataSourceBean.setUniqueResourceName("primary-db");
        dataSourceBean.setXaDataSourceClassName("com.mysql.cj.jdbc.MysqlXADataSource");
        
        Properties props = new Properties();
        props.put("url", "jdbc:mysql://...");
        props.put("user", "username");
        props.put("password", "password");
        dataSourceBean.setXaProperties(props);
        
        dataSourceBean.setMaxPoolSize(10);
        dataSourceBean.setMinPoolSize(1);
        return dataSourceBean;
    }

    // 두 번째 XA 데이터소스
    @Bean("jtaTBNWSDataSource")
    public DataSource jtaTBNWSDataSource() {
        AtomikosDataSourceBean dataSourceBean = new AtomikosDataSourceBean();
        dataSourceBean.setUniqueResourceName("secondary-db");
        dataSourceBean.setXaDataSourceClassName("com.mysql.cj.jdbc.MysqlXADataSource");
        
        Properties props = new Properties();
        props.put("url", "jdbc:mysql://...");
        props.put("user", "username");
        props.put("password", "password");
        dataSourceBean.setXaProperties(props);
        
        dataSourceBean.setMaxPoolSize(10);
        dataSourceBean.setMinPoolSize(1);
        return dataSourceBean;
    }

    // MyBatis SqlSessionFactory 설정들
    @Bean("gtgearSqlSessionFactory")
    public SqlSessionFactory gtgearSqlSessionFactory(@Qualifier("jtaGtgearDataSource") DataSource dataSource) throws Exception {
        SqlSessionFactoryBean factoryBean = new SqlSessionFactoryBean();
        factoryBean.setDataSource(dataSource);
        factoryBean.setMapperLocations(new PathMatchingResourcePatternResolver()
                .getResources("classpath:/mapper/*.xml"));
        return factoryBean.getObject();
    }

    @Bean("tbnwsSqlSessionFactory")
    public SqlSessionFactory tbnwsSqlSessionFactory(@Qualifier("jtaTBNWSDataSource") DataSource dataSource) throws Exception {
        SqlSessionFactoryBean factoryBean = new SqlSessionFactoryBean();
        factoryBean.setDataSource(dataSource);
        factoryBean.setMapperLocations(new PathMatchingResourcePatternResolver()
                .getResources("classpath:/mapper/*.xml"));
        return factoryBean.getObject();
    }

    @Bean("gtgearSqlSessionTemplate")
    public SqlSessionTemplate primarySqlSessionTemplate(@Qualifier("gtgearSqlSessionFactory") SqlSessionFactory sqlSessionFactory) {
        return new SqlSessionTemplate(sqlSessionFactory);
    }

    @Bean("tbnwsSqlSessionTemplate")
    public SqlSessionTemplate secondarySqlSessionTemplate(@Qualifier("tbnwsSqlSessionFactory") SqlSessionFactory sqlSessionFactory) {
        return new SqlSessionTemplate(sqlSessionFactory);
    }
}
```

## 사용법

JTA 트랜잭션 매니저를 사용하여 분산 트랜잭션 처리:

```java
@Transactional(transactionManager = "jtaTransaction")
public Integer someMethod(SomeParameter parameter) {
    // 여러 데이터소스에 걸친 작업들이 하나의 트랜잭션으로 처리됨
    // 어느 하나라도 실패하면 모든 작업이 롤백됨
}
```

## 분산 트랜잭션 이론

### ACID 속성
- **Atomicity(원자성)**: 트랜잭션은 모두 성공하거나 모두 실패해야 함
- **Consistency(일관성)**: 트랜잭션 전후로 데이터베이스 상태가 일관성을 유지
- **Isolation(고립성)**: 동시 실행되는 트랜잭션들이 서로 영향을 주지 않음
- **Durability(지속성)**: 커밋된 트랜잭션의 결과는 영구적으로 저장

### XA Protocol (eXtended Architecture)
분산 환경에서 여러 리소스 매니저 간의 트랜잭션을 조정하는 표준 프로토콜

#### 2PC (Two-Phase Commit) 과정
1. **Phase 1 - Prepare**:
   - 트랜잭션 매니저가 모든 리소스 매니저에게 prepare 요청
   - 각 리소스 매니저는 커밋 가능 여부를 응답 (YES/NO)
   - 모든 응답이 YES여야 다음 단계로 진행

2. **Phase 2 - Commit/Abort**:
   - 모든 prepare가 성공하면 commit 명령 전송
   - 하나라도 실패하면 abort 명령 전송
   - 각 리소스 매니저는 최종 작업 수행

#### XA의 장단점
**장점**:
- 강력한 데이터 일관성 보장
- 표준화된 프로토콜로 호환성 우수
- 복잡한 분산 시스템에서 안정성 제공

**단점**:
- 성능 오버헤드 (네트워크 라운드트립 증가)
- 블로킹 프로토콜로 인한 가용성 이슈
- 복잡한 구현과 디버깅

### JTA 아키텍처

#### 핵심 컴포넌트
1. **Transaction Manager (TM)**:
   - 글로벌 트랜잭션의 생명주기 관리
   - 2PC 프로토콜 조정
   - 리소스 매니저들과의 통신

2. **Resource Manager (RM)**:
   - 실제 리소스(DB, MQ 등)에 대한 접근 제공
   - XA 인터페이스 구현
   - 로컬 트랜잭션 관리

3. **Application**:
   - 비즈니스 로직 수행
   - Transaction Demarcation 수행

#### JTA vs Local Transaction

| 구분 | Local Transaction | JTA (Distributed Transaction) |
|------|------------------|--------------------------------|
| 범위 | 단일 리소스 | 여러 리소스 |
| 성능 | 빠름 | 상대적으로 느림 |
| 일관성 | 단일 DB 내에서만 | 여러 DB 간 보장 |
| 복잡도 | 단순 | 복잡 |
| 장애 복구 | 단순 | 복잡 (2PC 복구 로직) |

## Atomikos 상세 설정

### 트랜잭션 매니저 설정 옵션

```java
@Bean(initMethod = "init", destroyMethod = "close")
public UserTransactionManager userTransactionManager() {
    UserTransactionManager utm = new UserTransactionManager();
    
    // 강제 종료 방지 (애플리케이션 종료 시 진행 중인 트랜잭션 대기)
    utm.setForceShutdown(false);
    
    // 트랜잭션 로그 디렉토리 설정
    utm.setTransactionLogDir("./atomikos-logs");
    
    // 체크포인트 간격 (ms)
    utm.setCheckpointInterval(500);
    
    return utm;
}
```

### 트랜잭션 타임아웃 설정

```java
@Bean
public UserTransaction userTransaction() throws SystemException {
    UserTransactionImp uti = new UserTransactionImp();
    
    // 기본 타임아웃 60초
    uti.setTransactionTimeout(60);
    
    return uti;
}
```

### XA DataSource 고급 설정

```java
@Bean("primaryXADataSource")
public DataSource primaryXADataSource() {
    AtomikosDataSourceBean dsBean = new AtomikosDataSourceBean();
    
    // 필수 설정
    dsBean.setUniqueResourceName("primary-db");
    dsBean.setXaDataSourceClassName("com.mysql.cj.jdbc.MysqlXADataSource");
    
    // 커넥션 풀 설정
    dsBean.setMinPoolSize(5);           // 최소 커넥션 수
    dsBean.setMaxPoolSize(20);          // 최대 커넥션 수
    dsBean.setMaxIdleTime(300);         // 최대 유휴 시간 (초)
    dsBean.setBorrowConnectionTimeout(30); // 커넥션 대기 시간 (초)
    
    // XA 복구 설정
    dsBean.setMaintenanceInterval(60);   // 유지보수 간격 (초)
    dsBean.setMaxLifetime(0);           // 커넥션 최대 생존 시간 (0=무제한)
    
    // 테스트 쿼리
    dsBean.setTestQuery("SELECT 1");
    
    Properties props = new Properties();
    props.put("url", "jdbc:mysql://localhost:3306/db1");
    props.put("user", "username");
    props.put("password", "password");
    props.put("pinGlobalTxToPhysicalConnection", "true"); // XA 최적화
    dsBean.setXaProperties(props);
    
    return dsBean;
}
```

## 트랜잭션 격리 수준

### Spring @Transactional 속성

```java
@Transactional(
    transactionManager = "jtaTransaction",
    isolation = Isolation.READ_COMMITTED,    // 격리 수준
    propagation = Propagation.REQUIRED,      // 전파 속성
    timeout = 30,                            // 타임아웃 (초)
    rollbackFor = Exception.class,           // 롤백 예외
    noRollbackFor = IllegalArgumentException.class // 롤백 제외 예외
)
public void businessMethod() {
    // 비즈니스 로직
}
```

### 격리 수준 종류
1. **READ_UNCOMMITTED**: Dirty Read 발생 가능
2. **READ_COMMITTED**: Dirty Read 방지, Non-repeatable Read 발생 가능
3. **REPEATABLE_READ**: Non-repeatable Read 방지, Phantom Read 발생 가능
4. **SERIALIZABLE**: 모든 동시성 문제 방지, 성능 저하

### 전파 속성 (Propagation)
- **REQUIRED**: 기존 트랜잭션 참여, 없으면 새로 생성
- **REQUIRES_NEW**: 항상 새 트랜잭션 생성
- **SUPPORTS**: 기존 트랜잭션 참여, 없어도 됨
- **MANDATORY**: 기존 트랜잭션 필수, 없으면 예외
- **NOT_SUPPORTED**: 트랜잭션 없이 실행
- **NEVER**: 트랜잭션 있으면 예외
- **NESTED**: 중첩 트랜잭션 사용

## 모니터링 및 디버깅

### 로그 설정

```properties
# Atomikos 로그 레벨
logging.level.com.atomikos=DEBUG

# JTA 트랜잭션 로그
logging.level.org.springframework.transaction=DEBUG

# SQL 실행 로그
logging.level.org.mybatis=DEBUG
```

### 트랜잭션 상태 확인

```java
@Autowired
private PlatformTransactionManager transactionManager;

public void checkTransactionStatus() {
    TransactionStatus status = transactionManager.getTransaction(
        new DefaultTransactionDefinition()
    );
    
    System.out.println("Is new transaction: " + status.isNewTransaction());
    System.out.println("Has savepoint: " + status.hasSavepoint());
    System.out.println("Is rollback only: " + status.isRollbackOnly());
    System.out.println("Is completed: " + status.isCompleted());
}
```

## 성능 최적화 및 주의사항

### 성능 최적화
1. **커넥션 풀 튜닝**: 적절한 min/max 커넥션 수 설정
2. **타임아웃 최적화**: 불필요하게 긴 타임아웃 방지
3. **배치 처리**: 대량 데이터 처리 시 청크 단위로 분할
4. **읽기 전용 트랜잭션**: `@Transactional(readOnly = true)` 활용

### 주의사항
1. **데드락 방지**: 리소스 접근 순서 일관성 유지
2. **트랜잭션 범위 최소화**: 필요한 범위만 트랜잭션으로 묶기
3. **장시간 트랜잭션 방지**: 사용자 입력 대기 등은 트랜잭션 외부에서
4. **예외 처리**: 적절한 rollback 조건 설정

### 대안 패턴
- **Saga Pattern**: 장기 실행 프로세스에 적합
- **Event Sourcing**: 이벤트 기반 일관성 관리
- **CQRS**: 읽기/쓰기 분리로 성능 향상
